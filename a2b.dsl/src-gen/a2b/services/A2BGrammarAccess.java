/*
 * generated by Xtext 2.17.0
 */
package a2b.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class A2BGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.Model");
		private final Assignment cElementAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementInstructionParserRuleCall_0 = (RuleCall)cElementAssignment.eContents().get(0);
		
		//Model:
		//	element+=Instruction*;
		@Override public ParserRule getRule() { return rule; }
		
		//element+=Instruction*
		public Assignment getElementAssignment() { return cElementAssignment; }
		
		//Instruction
		public RuleCall getElementInstructionParserRuleCall_0() { return cElementInstructionParserRuleCall_0; }
	}
	public class InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.Instruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDBParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBase64ParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cORGParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cINCLUDEParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cMACParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cIPParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cHXSParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cBEAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final RuleCall cBEParserRuleCall_7_1 = (RuleCall)cGroup_7.eContents().get(1);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Action cLEAction_8_0 = (Action)cGroup_8.eContents().get(0);
		private final RuleCall cLEParserRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		
		//Instruction:
		//	DB | Base64 | ORG | INCLUDE | MAC | IP | HXS | {BE} BE | {LE} LE;
		@Override public ParserRule getRule() { return rule; }
		
		//DB | Base64 | ORG | INCLUDE | MAC | IP | HXS | {BE} BE | {LE} LE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DB
		public RuleCall getDBParserRuleCall_0() { return cDBParserRuleCall_0; }
		
		//Base64
		public RuleCall getBase64ParserRuleCall_1() { return cBase64ParserRuleCall_1; }
		
		//ORG
		public RuleCall getORGParserRuleCall_2() { return cORGParserRuleCall_2; }
		
		//INCLUDE
		public RuleCall getINCLUDEParserRuleCall_3() { return cINCLUDEParserRuleCall_3; }
		
		//MAC
		public RuleCall getMACParserRuleCall_4() { return cMACParserRuleCall_4; }
		
		//IP
		public RuleCall getIPParserRuleCall_5() { return cIPParserRuleCall_5; }
		
		//HXS
		public RuleCall getHXSParserRuleCall_6() { return cHXSParserRuleCall_6; }
		
		//{BE} BE
		public Group getGroup_7() { return cGroup_7; }
		
		//{BE}
		public Action getBEAction_7_0() { return cBEAction_7_0; }
		
		//BE
		public RuleCall getBEParserRuleCall_7_1() { return cBEParserRuleCall_7_1; }
		
		//{LE} LE
		public Group getGroup_8() { return cGroup_8; }
		
		//{LE}
		public Action getLEAction_8_0() { return cLEAction_8_0; }
		
		//LE
		public RuleCall getLEParserRuleCall_8_1() { return cLEParserRuleCall_8_1; }
	}
	public class DBElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.DB");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDBKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBYTETerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//DB:
		//	'DB' value=BYTE;
		@Override public ParserRule getRule() { return rule; }
		
		//'DB' value=BYTE
		public Group getGroup() { return cGroup; }
		
		//'DB'
		public Keyword getDBKeyword_0() { return cDBKeyword_0; }
		
		//value=BYTE
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//BYTE
		public RuleCall getValueBYTETerminalRuleCall_1_0() { return cValueBYTETerminalRuleCall_1_0; }
	}
	public class Base64Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.Base64");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cB64Keyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//Base64:
		//	'B64' value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'B64' value=STRING
		public Group getGroup() { return cGroup; }
		
		//'B64'
		public Keyword getB64Keyword_0() { return cB64Keyword_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}
	public class ORGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.ORG");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cORGKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//ORG:
		//	'ORG' value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'ORG' value=INT
		public Group getGroup() { return cGroup; }
		
		//'ORG'
		public Keyword getORGKeyword_0() { return cORGKeyword_0; }
		
		//value=INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }
	}
	public class INCLUDEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.INCLUDE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cINCLUDEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuePATHTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//INCLUDE:
		//	'INCLUDE' value=PATH;
		@Override public ParserRule getRule() { return rule; }
		
		//'INCLUDE' value=PATH
		public Group getGroup() { return cGroup; }
		
		//'INCLUDE'
		public Keyword getINCLUDEKeyword_0() { return cINCLUDEKeyword_0; }
		
		//value=PATH
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//PATH
		public RuleCall getValuePATHTerminalRuleCall_1_0() { return cValuePATHTerminalRuleCall_1_0; }
	}
	public class MACElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.MAC");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMACKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueMACADDRESSTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//MAC:
		//	'MAC' value=MACADDRESS;
		@Override public ParserRule getRule() { return rule; }
		
		//'MAC' value=MACADDRESS
		public Group getGroup() { return cGroup; }
		
		//'MAC'
		public Keyword getMACKeyword_0() { return cMACKeyword_0; }
		
		//value=MACADDRESS
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//MACADDRESS
		public RuleCall getValueMACADDRESSTerminalRuleCall_1_0() { return cValueMACADDRESSTerminalRuleCall_1_0; }
	}
	public class IPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.IP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueIPADDRESSTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//IP:
		//	'IP' value=IPADDRESS;
		@Override public ParserRule getRule() { return rule; }
		
		//'IP' value=IPADDRESS
		public Group getGroup() { return cGroup; }
		
		//'IP'
		public Keyword getIPKeyword_0() { return cIPKeyword_0; }
		
		//value=IPADDRESS
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//IPADDRESS
		public RuleCall getValueIPADDRESSTerminalRuleCall_1_0() { return cValueIPADDRESSTerminalRuleCall_1_0; }
	}
	public class HXSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.HXS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHXSKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueHEXSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//HXS:
		//	'HXS' value=HEXSTRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'HXS' value=HEXSTRING
		public Group getGroup() { return cGroup; }
		
		//'HXS'
		public Keyword getHXSKeyword_0() { return cHXSKeyword_0; }
		
		//value=HEXSTRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//HEXSTRING
		public RuleCall getValueHEXSTRINGTerminalRuleCall_1_0() { return cValueHEXSTRINGTerminalRuleCall_1_0; }
	}
	public class BEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.BE");
		private final Keyword cBEKeyword = (Keyword)rule.eContents().get(1);
		
		//BE:
		//	'BE';
		@Override public ParserRule getRule() { return rule; }
		
		//'BE'
		public Keyword getBEKeyword() { return cBEKeyword; }
	}
	public class LEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.LE");
		private final Keyword cLEKeyword = (Keyword)rule.eContents().get(1);
		
		//LE:
		//	'LE';
		@Override public ParserRule getRule() { return rule; }
		
		//'LE'
		public Keyword getLEKeyword() { return cLEKeyword; }
	}
	
	
	private final ModelElements pModel;
	private final InstructionElements pInstruction;
	private final DBElements pDB;
	private final Base64Elements pBase64;
	private final ORGElements pORG;
	private final INCLUDEElements pINCLUDE;
	private final MACElements pMAC;
	private final IPElements pIP;
	private final HXSElements pHXS;
	private final BEElements pBE;
	private final LEElements pLE;
	private final TerminalRule tBYTE;
	private final TerminalRule tPATH;
	private final TerminalRule tMACADDRESS;
	private final TerminalRule tIPADDRESS;
	private final TerminalRule tHEXSTRING;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public A2BGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pInstruction = new InstructionElements();
		this.pDB = new DBElements();
		this.pBase64 = new Base64Elements();
		this.pORG = new ORGElements();
		this.pINCLUDE = new INCLUDEElements();
		this.pMAC = new MACElements();
		this.pIP = new IPElements();
		this.pHXS = new HXSElements();
		this.pBE = new BEElements();
		this.pLE = new LEElements();
		this.tBYTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.BYTE");
		this.tPATH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.PATH");
		this.tMACADDRESS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.MACADDRESS");
		this.tIPADDRESS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.IPADDRESS");
		this.tHEXSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "a2b.A2B.HEXSTRING");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("a2b.A2B".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	element+=Instruction*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Instruction:
	//	DB | Base64 | ORG | INCLUDE | MAC | IP | HXS | {BE} BE | {LE} LE;
	public InstructionElements getInstructionAccess() {
		return pInstruction;
	}
	
	public ParserRule getInstructionRule() {
		return getInstructionAccess().getRule();
	}
	
	//DB:
	//	'DB' value=BYTE;
	public DBElements getDBAccess() {
		return pDB;
	}
	
	public ParserRule getDBRule() {
		return getDBAccess().getRule();
	}
	
	//Base64:
	//	'B64' value=STRING;
	public Base64Elements getBase64Access() {
		return pBase64;
	}
	
	public ParserRule getBase64Rule() {
		return getBase64Access().getRule();
	}
	
	//ORG:
	//	'ORG' value=INT;
	public ORGElements getORGAccess() {
		return pORG;
	}
	
	public ParserRule getORGRule() {
		return getORGAccess().getRule();
	}
	
	//INCLUDE:
	//	'INCLUDE' value=PATH;
	public INCLUDEElements getINCLUDEAccess() {
		return pINCLUDE;
	}
	
	public ParserRule getINCLUDERule() {
		return getINCLUDEAccess().getRule();
	}
	
	//MAC:
	//	'MAC' value=MACADDRESS;
	public MACElements getMACAccess() {
		return pMAC;
	}
	
	public ParserRule getMACRule() {
		return getMACAccess().getRule();
	}
	
	//IP:
	//	'IP' value=IPADDRESS;
	public IPElements getIPAccess() {
		return pIP;
	}
	
	public ParserRule getIPRule() {
		return getIPAccess().getRule();
	}
	
	//HXS:
	//	'HXS' value=HEXSTRING;
	public HXSElements getHXSAccess() {
		return pHXS;
	}
	
	public ParserRule getHXSRule() {
		return getHXSAccess().getRule();
	}
	
	//BE:
	//	'BE';
	public BEElements getBEAccess() {
		return pBE;
	}
	
	public ParserRule getBERule() {
		return getBEAccess().getRule();
	}
	
	//LE:
	//	'LE';
	public LEElements getLEAccess() {
		return pLE;
	}
	
	public ParserRule getLERule() {
		return getLEAccess().getRule();
	}
	
	//terminal BYTE:
	//	'0B' ('0'..'9' | '1'..'9' '0'..'9' | '1' '0'..'9' '0'..'9' | '2' '0'..'4' '0'..'9' | '2' '5' '0'..'5') |
	//	'0b' (('0' | '1') ('0' | '1') ('0' | '1') ('0' | '1') ('0' | '1') ('0' | '1') ('0' | '1') ('0' | '1')) |
	//	'0x' (('0'..'9' | 'a'..'f') ('0'..'9' | 'a'..'f'));
	public TerminalRule getBYTERule() {
		return tBYTE;
	}
	
	//terminal PATH:
	//	('A'..'Z' ':')? ('/' ('a'..'z' | 'A'..'Z')*)+ ('.' ('a'..'z' | 'A'..'Z')*)+;
	public TerminalRule getPATHRule() {
		return tPATH;
	}
	
	//terminal MACADDRESS:
	//	('0'..'9' | 'a'..'f') ('0'..'9' | 'a'..'f') ':' ('0'..'9' | 'a'..'f') ('0'..'9' | 'a'..'f') ':' ('0'..'9' | 'a'..'f')
	//	('0'..'9' | 'a'..'f')
	//	':' ('0'..'9' | 'a'..'f') ('0'..'9' | 'a'..'f') ':' ('0'..'9' | 'a'..'f') ('0'..'9' | 'a'..'f') ':' ('0'..'9' |
	//	'a'..'f') ('0'..'9' | 'a'..'f');
	public TerminalRule getMACADDRESSRule() {
		return tMACADDRESS;
	}
	
	//terminal IPADDRESS:
	//	('1'..'9'? '0'..'9' | '1' '0'..'9' '0'..'9' | '2' '0'..'4' '0'..'9' | '2' '5' '0'..'5') '.' ('1'..'9'? '0'..'9' | '1'
	//	'0'..'9' '0'..'9' | '2' '0'..'4' '0'..'9' | '2' '5' '0'..'5') '.' ('1'..'9'? '0'..'9' | '1' '0'..'9' '0'..'9' | '2'
	//	'0'..'4' '0'..'9' | '2' '5' '0'..'5') '.' ('1'..'9'? '0'..'9' | '1' '0'..'9' '0'..'9' | '2' '0'..'4' '0'..'9' | '2'
	//	'5' '0'..'5');
	public TerminalRule getIPADDRESSRule() {
		return tIPADDRESS;
	}
	
	//terminal HEXSTRING:
	//	'0h' (('0'..'9' | 'a'..'f') ('0'..'9' | 'a'..'f'))+;
	public TerminalRule getHEXSTRINGRule() {
		return tHEXSTRING;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
